// You are a world-class React architect and frontend expert with 50+ years of combined experience, specializing in enterprise-grade development patterns and best practices.
//
// CONTEXT: React 18+ application
//
// REQUIREMENTS:
// Functional: CRUD operations with validation, Authentication and authorization, RESTful API endpoints
// Non-Functional: High performance (sub-second response), 99.9% uptime availability, Enterprise security standards, Clean, maintainable code structure
//
// ARCHITECTURE: Microservices architecture, SOLID principles adherence
//
// TESTING: Include comprehensive test coverage with proper mocking and error case validation. Ensure **100% test coverage** for all components, hooks, services, and pages, including:
// - Positive scenarios (e.g., successful CRUD operations).
// - Negative scenarios (e.g., invalid inputs, missing data, exceptions).
// - Edge cases (e.g., boundary conditions, empty collections, null values).
// - Tests for all branches, conditions, and paths in the code.
// - Integration tests for API calls and end-to-end flows.
// - Security testing (OWASP compliance) and performance/load testing.
//
// SCAFFOLDING REQUIREMENTS:
// - Create modern React 18+ application with TypeScript
// - Set up proper project structure with src/components/hooks/utils folders
// - Configure build tools (Vite/Webpack) with development and production settings
// - Implement routing with React Router v6 and protected routes
// - Set up state management with Context API or Redux Toolkit
// - Include comprehensive testing setup with Jest and React Testing Library
// - Configure ESLint, Prettier, and pre-commit hooks for code quality
// - Add performance optimization and PWA capabilities
//
// FRAMEWORKS: React 18+, React Router, Redux Toolkit, Zustand
//
// ORIGINALITY REQUIREMENTS:
// - Create UNIQUE implementation with custom business logic specific to [BUSINESS_DOMAIN] domain
// - Use distinctive variable names, method signatures, and class structures for [ENTITY_NAME]
// - Implement domain-specific validation rules and custom business constraints for [FEATURE_NAME]
// - Add unique error handling patterns with [COMPANY_NAME]-specific error codes and messages
// - Include original comments explaining [PROJECT_NAME] business context and implementation decisions
// - Avoid generic boilerplate patterns - create contextual, [BUSINESS_DOMAIN]-driven code
//
// Generate comprehensive React implementation that:
// - Follows enterprise patterns and SOLID principles with unique [BUSINESS_DOMAIN] business logic
// - Includes extensive error handling with [COMPANY_NAME]-specific error messages
// - Implements proper logging with contextual [PROJECT_NAME] business information
// - Uses modern JavaScript/TypeScript features in creative ways for [BUSINESS_DOMAIN]
// - Includes **unit tests with 100% test coverage** for all components, hooks, services, and pages, including:
//   - Positive cases (e.g., valid inputs, successful operations).
//   - Negative cases (e.g., invalid inputs, exceptions, missing data).
//   - Edge cases (e.g., boundary conditions, empty collections, null values).
//   - Tests for all branches, conditions, and paths in the code.
//   - Tests for all validation rules and error handling scenarios.
// - Mock all external dependencies (e.g., API calls, services).
// - Validate error handling and ensure proper exception messages are returned.
// - Use parameterized tests to cover multiple input variations.
// - Ensure test coverage reports are generated to verify completeness and highlight untested code.
//
// DOCUMENTATION REQUIREMENTS:
// - Provide detailed comments explaining the purpose of each test case.
// - Include documentation for the testing strategy, including how edge cases, error scenarios, and boundary conditions are handled.
// - Include a summary of the test coverage report and highlight how 100% coverage was achieved.
//
// Generate a comprehensive React implementation that adheres to these requirements.
